\chapter{\IfLanguageName{dutch}{Stand van zaken}{State of the art}}%
\label{ch:stand-van-zaken}

% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.

In dit hoofdstuk wordt de huidige stand van zaken besproken binnen het onderzoeksdomein. Het doel is om een duidelijk beeld te scheppen van de huidige situatie en de bestaande kennis over het onderwerp en zo een goede basis te vormen voor het verdere verloop van het onderzoek. In dit hoofdstok wordt er eerst gesproken over het verschil tussen Native, Cross-Platform en Hybrid Development. Het is namelijk noodzakelijk hier een goed beeld van te vormen om de juiste omkadering te geven van beide frameworks. Vervolgens wordt er dieper ingegaan op de Android infrastructuur. Vanwege de verschillen tussen de infrastructuur en werking van React Native en Ionic, is het van belang ook een begrip te hebben van de onderliggende componenten en hun relaties. Daarna zal er een vergelijking gemaakt worden tussen de twee frameworks en zullen er verklaringen of redenen gegeven worden op welke vlakken zij kunnen verschillen en waarom. Tot slot wordt er nog een korte paragraaf gewijd aan de performantie van mobiele applicaties omtrent streaming en hoe dit een impact kan hebben op de keuze van het framework.

\paragraph{Native vs Cross-Platform vs Hybrid}

Voordat er dieper ingegaan wordt op React Native en Ionic, is het belangrijk om ze te situeren binnen Mobile Development. Er kunnen drie grote categorieën onderscheiden worden: Native, Cross-Platform en Hybrid (bron12). Native Development is het "native" ontwikkelen van een applicatie voor een specifiek platform. Dit wil zeggen dat een applicatie ontwikkeld wordt in de programmeertaal van het platform, zoals Java of Kotlin voor Android-toestellen en Objective-C of Swift voor iOS-toestellen (bron 11, bron 1). Met andere woorden maken deze applicaties gebruik van de officiële ontwikkelingsomgevingen en architecturen van het platform in kwestie. Dit brengt een aantal voordelen met zich mee. Door het gebruik van de native-architectuur en native-UI-tools, kan men profiteren van alle functionaliteiten die het platform aanbiedt. Dat zorgt dan weer voor een optimale performantie en bijgevolg een betere gebruikservaring. Bovendien vereisen ook bepaalde applicaties een native ontwikkeling. Denk hierbij aan programma's die veel resources nodig hebben zoals games (bron12). De keuze voor een native-aanpak brengt echter toch wat nadelen met zich mee. Mobiele applicaties worden echter vaak ontwikkeld met meerdere platformen tegelijk in gedachten, waardoor dezelfde app als het ware dubbel moet worden geprogrammeerd, met als gevolg hogere kosten en development tijdsduur (bron12). Bovendien vereist dit extra kennis van de medewerkers en ontwikkelaars omdat er voor elk platform een andere programmeertaal gebruikt wordt. Kleinere organisaties of start-ups hebben vaak niet altijd voldoende middelen om zulke projecten te financieren. Vandaar dat Cross-Platform en Hybrid Development een oplossing kan bieden.

Het grote voordeel aan Cross-Platform development is dat het steunt op het principe: "write once, run everywhere" (bron12). Dit wil zeggen dat ontwikkelaars de applicatie slechts één keer moeten implementeren in een programmeertaal naar keuze en vervolgens kunnen uitrollen op één of meerdere platformen tegelijk zonder hierbij platform-specifieke code te moeten schrijven (bron12). In vele gevallen maakt men gebruik van een framework dat gebaseerd is op talen die ondersteund worden op verschillende platformen, zoals bijvoorbeeld JavaScript. Vervolgens maakt het framework gebruik van een cross-compiler die de code vertaalt naar de platformspecifieke code (bron1). De applicatie heeft bijgevolg een soort van "native" look-and-feel, onder meer omdat native-componenten van het toestel hergebruikt worden (bron2). Belangrijk hierbij te vermelden is dat het nog altijd geen echte native-applicatie is vanwege de cross-compiler. Deze tussenstap brengt namelijk een zekere overhead met zich mee, wat kan leiden tot mindere performantie in vergelijking met een echt native-programma (bron12). Bovendien is het niet altijd mogelijk om alle platformspecifieke functionaliteiten te gebruiken (bron12). Wat deze beperkingen zijn, hangt natuurlijk af van framework tot framework. Wat wel vaststaat is dat Cross-Platform Development, in tegenstelling tot Native Development, een pak goedkoper is en sneller verloopt juist vanwege het feit dat er slechts één codebase is.

Tot slot is er nog Hybrid Development. Dit type bevindt zich ergens tussen Native en Cross-Platform Development. Uit verschillende bronnen bleek dat de termen Cross-Platform en Hybrid Development vaak door elkaar worden gebruikt, terwijl er toch een aanzienlijk verschil is tussen beiden (bron12, bron1, bron11). Hybrid Development maakt gebruik van webtechnologieën zoals HTML, CSS en JavaScript om een applicatie te ontwikkelen. Er is hier dus opnieuw sprake van herbruikbare code en dus het eenmalig implementeren van de applicatie. Het grote verschil met Cross-Platform Development is dat Hybrid Development de code in een webview of browser-engine van het platform plaatst (bron11, bron1). Bij Android is dit het WebView component, bij iOS wordt het UIWebView component gebruikt (bron4). Vervolgens wordt de applicatie verpakt in een native container waardoor de applicatie een soort van "native" applicatie wordt. Toch valt hierbij op te merken dat de applicatie niet Native is, en ook geen gebruik maakt van native-componenten zoals bij Cross-Platform Development (bron12, bron6). Vanwege dit laatste, kampen zij soms met een inconsistente User Interface, wat natuurlijk een impact kan hebben op de gebruikerservaring (bron12).

Het verschil tussen Cross-Platform en Hybrid development vormt een kernaspect binnen dit onderzoek. Ionic wordt namelijk bestempeld als een Hybrid framework, terwijl React Native een Cross-Platform framework is (bron4, bron1). Beiden zijn echter mogelijkheden om eenmalig een programma te coderen en vervolgens uit te rollen op meerdere platformen. Beiden zijn bovendien ook niet Native, met de bijhorende impact op de performantie. Hoe de infrastructuur van beide frameworks in elkaar zit, zal in een volgend onderdeel besproken worden.


\paragraph{Android infrastructuur}

https://www.researchgate.net/profile/Umesh-Tupe/publication/354576500_A_Literature_Review_on_Android_-A_Mobile_Operating_system/links/6140969897d4d76020747981/A-Literature-Review-on-Android-A-Mobile-Operating-system.pdf (bron13)
(bron7)
https://source.android.com/docs/core/runtime (bron14)

Een belangrijk aspect van dit onderzoek is de infrastructuur van Android. Android is een besturingssysteem ontwikkeld door Google en is gebaseerd op de Linux-kernel (bron13). Het besturingssysteem is open-source en wordt voornamelijk gebruikt op smartphones en tablets. In dit onderdeel wordt de Android infrastructuur besproken en worden de verschillende lagen toegelicht. Dit is belangrijk om een goed beeld te vormen van de onderliggende componenten en hun relaties. Dit zal later in het onderzoek helpen om de verschillen tussen React Native en Ionic beter te begrijpen.

TODO: INSERT AFBEELDING

De eerste en bovenste laag van het Android OS is de System Apps of systeemapplicaties (bron7, bron13). Dit zijn de applicaties die standaard geïnstalleerd zijn op elk Android-toestel. Denk hierbij aan de telefoon-applicatie, de berichten-applicatie, de email-applicatie, enzoverder (bron7). Deze standaardapplicaties hebben verder geen speciale betekenis naast het feit dat ze standaard met het besturingssysteem worden geïnstalleerd. De standaardbrowser die met het toestel komt, kan nog altijd vervangen worden door een andere browser.

De tweede laag noemt het Java API Framework (bron7). Dit is het framework dat ontwikkelaars gebruiken om applicaties te ontwikkelen voor Android. Het bevat een verzameling aan API's geschreven in Java die de features voorstellen van het Android OS. Het bevat een "View System" die de ontwikkelaar de mogelijkheid biedt om via buttons, grids, textboxes, enzoverder een User Interface te bouwen (bron7, bron13). Hierbinnen zit ook een web browser engine die een belangrijke rol speelt bij Hybrid Development. Content Providers is een ander onderdeel binnenin het Java API Framework. Dit is een soort mechanisme die het mogelijk maakt om data van andere applicaties te delen (bron7). Een voorbeeld hiervan is de Contact Provider die een gebruiker toelaat om contactinformatie uit de contacten-app te hergebruiken of zelf te delen met de applicatie, of bijvoorbeeld de Calendar Provider om events of afspraken op de agenda-app op te slaan of te delen. Tot slot zijn er ook nog de verschillende Managers binnen het Java API Framework (bron7). Deze staan in voor de verschillende services die het Android OS aanbiedt. Zo is er de Notification Manager die instaat voor de notificaties en de Location Manager die de locatie van de gebruiker kan bepalen, om enkele voorbeelden te geven.

De volgende laag zijn de Native C/C++ Libraries (bron7, bron13). Een groot deel van de componenten binnen Android zijn geschreven in C/C++. Android staat toe om de meeste van deze libraries via een Java API te gebruiken. Toch kan het mogelijk zijn dat een ontwikkelaar zijn applicatie in C/C++ wil schrijven. Dankzij deze laag kan er op een Native manier in C/C++ geprogrammeerd worden. Om deze laag toch nog wat beter uit te leggen, kan dit geïllustreerd worden aan de hand van een voorbeeld. Stel dat een ontwikkelaar bepaalde 2D of 3D objecten wil gaan renderen in zijn of haar applicatie, bijvoorbeeld bij een video game. De Native C/C++ Libraries bevatten de OpenGL ES library die aan de hand van de C/C++ programmeertaal objecten kan renderen (bron7, bron13). Toch biedt Android de optie om deze library ook te gebruiken in de bovenstaande Java API Framework laag met behulp van de Java OpenGL API. Zo is het nog steeds mogelijk om via de Java programmeertaal objecten te renderen, maar dan wel met de achterliggende hulp van de OpenGL ES library (bron7). Deze laag kan eigenlijk gebruikt worden om op een meer native manier te programmeren, maar is niet noodzakelijk voor de ontwikkeling van een Android-applicatie. Het kan echter wel meer flexibiliteit bieden.

Vervolgens is er de Android Runtime. Dit is de laag waar de applicaties worden uitgevoerd. Hierbij is het belangrijkste component de Android Runtime (ART) (bron7). Elke applicatie die op het Android OS draait, runt in een eigen proces met een eigen instantie van dit ART component. ART maakt gebruik van Dalvik Executable (.dex) bestanden, een bestandsformaat dat specifiek is ontwikkeld voor Android en geoptimaliseerd is om programma's te draaien met lage geheugenvereisten (bron14). Hierin schuilt als het ware de kracht om applicaties die veel resources vereisen, te draaien op een toestel met relatief beperkte kracht. Bovendien biedt ART verschillende runtime functionaliteiten zoals Ahead-of-time (AOT) compilatie, Just-in-time (JIT) compilatie en garbage collection mogelijkheden (bron7, bron14). AOT compilatie zorgt ervoor dat de applicatie gecompileerd wordt voordat deze wordt uitgevoerd, wat de performantie ten goede komt. JIT compilatie daarentegen compileert de applicatie tijdens het uitvoeren, wat de opstarttijd van de applicatie ten goede komt. ART is de opvolger van Dalvik, de vorige runtime van Android. Dalvik maakte alleen gebruik van Just-in-time compilatie, wat de algemene performantie van applicaties soms kon vertragen (bron13). ART is compatibel met Android 5.0 (Lollipop) en is sindsdien de standaard runtime van Android (bron7, bron13).

Nu komen we bij de voorlaatste laag, namelijk de Hardware Abstraction Layer of kortweg HAL (bron7). Deze laag biedt meerdere interfaces aan om te kunnen communiceren met de onderliggende hardwarelaag. Ze voorkomt dat ontwikkelaars rechtstreeks met de hardware moeten communiceren. Zo hebben de camera, de Bluetooth, de audio, enzoverder allemaal een eigen interface (bron7). Wanneer een API framework uit de bovenliggende laag een bepaalde hardwarefunctie wil gebruiken, zal de HAL de desbetreffende library module inladen. Deze module zal dan de juiste hardwarefunctie aanroepen en de resultaten terugsturen naar het API framework (bron7).

Tot slot is er nog de laatste laag: de Linux Kernel (bron7, bron13). Dit wordt ook wel gezien als de kern van het Android platform. Een belangrijk proces is dat het ART component deze kernel gebruikt om het geheugen en de processen te gaan beheren (bron7, bron13). Zaken zoals threading en low-level memory management worden hier geregeld. Vanuit deze laag wordt er uiteindelijk gecommuniceerd met de onderliggende hardware van het toestel om de applicatie te draaien (bron13).

\paragraph{React Native}

Dit onderzoek focust zich specifiek op React Native en Ionic. React Native is een open-source framework ontwikkeld door Facebook. Het werd gelanceerd in 2015 en was oorspronkelijk bedoeld voor het programmeren van mobiele applicaties voor iOS-toestellen (bron1). In september van datzelfde jaar, enkele maanden na de initiële lancering, was het ook mogelijk om via dezelfde codebase de applicatie te releasen op Android (bron1).

React Native maakt gebruik van het React framework, een ander open source framework, die aan de hand van JavaScript de mogelijkheid biedt om complexe user interfaces te bouwen (https://reactnative.dev/docs/intro-react#your-first-component). Een applicatie gebouwd in React Native of React maakt gebruik van JSX-componenten, een combinatie tussen XML binnenin JavaScript code, wat extra flexibiliteit biedt om ook variabelen te declareren binnenin dezelfde componenten (bron2?). Bij zowel Android als iOS development bestaat de user interface uit "Views" (https://reactnative.dev/docs/intro-react-native-components). Deze vormen de bouwstenen van het scherm van de applicatie en kunnen opgebouwd worden uit meerdere sub-componenten. React Native biedt een groot aantal van die standaardcomponenten aan zoals buttons, inputvelden, sliders, enzoverder. Het principe achter React Native is dat je de Views binnenin Android en iOS kunt gebruiken aan de hand van deze React componenten. Het "<TextInput>" component binnenin React Native bijvoorbeeld, wordt omgezet naar een "<EditText>"-View in Android en een "<UITextField>"-View in iOS.

De React Native applicatie voor de Proof-of-Concept zal gebruikmaken van het nieuwe Fabric-rendering principe. Hiervoor maakte React Native gebruik van "The Bridge", waarbij de JavaScript code binnenin React werd omgezet naar native-componenten (bron???). Dit principe is helemaal vernieuwd met behulp van Fabric. Om de complexiteit zo laag mogelijk te houden, zal dit uitgelegd worden aan de hand van een voorbeeld die ook werd gegeven op (bron). In onderstaand voorbeeld hebben we een React-component "Component" gedefiniëerd. Dit component bevat een <View> component met daarin een <Text> component. De code ziet er als volgt uit:

\begin{LVerbatim}
function Component() {
  return (
    <View>
      <Text>Hello, World</Text>
    </View>
  );
}
\end{LVerbatim}

In React onderscheiden we twee type components: React Composite Components en React Host Components. React Composite Components zijn de componenten die door de ontwikkelaar zelf gedefinieerd worden, zoals "Component" in bovenstaande code. React Host Components zijn de standaardcomponenten die React Native aanbiedt, zoals de <View> en <Text> componenten (https://reactnative.dev/architecture/glossary#react-composite-components). Eens de code moet worden gerendered, zal React deze gedefinieerde componenten eerst omzetten in een React Element Tree. Hierbij worden alle React Host Components, maar niet de zelf gedeclareerde React Composite Components, omgezet naar een boomstructuur van React Elementen. Een React Element is een JavaScript object dat alle informatie bevat over het component en wat er precies op het scherm moet worden weergegeven (https://reactnative.dev/architecture/glossary#react-element-tree-and-react-element). Tegelijkertijd gaat de Fabric renderer een Shadow Tree aanmaken. Voor elk React Element wordt een React Shadow Node aangemaakt en wordt deze in een gelijkaardige boomstructuur gestoken. Het verschil tussen een React Element en een React Shadow Node is dat de React Element in JavaScript is gedefinieerd en de React Shadow Node in C++ (https://reactnative.dev/architecture/glossary#react-shadow-node). Zo bestaat er in het bovenstaande voorbeeld een React Element <View> en een React Shadow Node <ViewShadowNode>. Nadat de Shadow Tree is aangemaakt, wordt er een commit getriggered.

(insert foto)

De volgende fase is dan de Commit fase. Deze bestaat uit twee grote stappen: de Layout Calculation en Tree Promotion. Bij Layout Calculation wordt alle informatie omtrent de layout, die oorspronkelijk afkomstig is van de React Element Tree, berekend. Zo wordt voor elk component bepaald hoeveel ruimte ze gaat innemen op het scherm. Bij Tree Promotion wordt de nieuwe Shadow Tree als het ware "gepromoveerd" en klaargezet om gemounted te worden. In eenvoudigere termen betekent dit dat de nieuwe Shadow Tree klaarstaat om op het scherm te worden weergegeven. Zowel de Layout Calculation als de Tree Promotion verlopen asynchroon met elkaar en worden voor het grootste deel in C++ berekend.

(TODO: voordelen van Fabric en C++ berekeningen)

De laatste fase, de Mount fase, bestaat uit het renderen van het scherm. Hierbij wordt voor elke React Shadow Node uit de Shadow Tree, samen met de berekende layout informatie, een Host View aangemaakt. Een Host View is een View die een instantie is van een Android View of een iOS UIView. De React Shadow Nodes worden dus met andere woorden omgezet naar native View-componenten van het desbetreffende platform. Vandaar de naam "Native" in React Native.

Het is belangrijk hierbij te vermelden dat React Native niet een volledig "Native" framework is. Uit verschillende bronnen bestaan er vaak nog wat misconcepties vanwege deze naam en wordt het dus vaak foutief bestempeld. Het is en blijft een Cross-Platform framework. Het maakt inderdaad gebruik van native componenten, maar vanwege de cross-compiling tussenstap kan dit niet geplaatst worden onder Native Development.

https://reactnative.dev/architecture/render-pipeline
https://reactnative.dev/architecture/glossary
https://reactnative.dev/docs/intro-react

\paragraph{Ionic}

(nog verder uit te breiden)

https://ionic.io/resources/articles/building-cross-platform-apps-with-capacitor
https://ionicframework.com/docs#license
https://capacitorjs.com/docs/android

Ionic is net zoals React Native een open source framework. {bron8} laat toe om via een webframework naar keuze zoals Angular, React of Vue een applicatie te ontwikkelen die vervolgens kan uitgerold worden op meerdere platformen. Het grote voordeel aan Ionic is dat het gebruik maakt van webtechnologieën zoals HTML, CSS en JavaScript. Dit heeft als gevolg dat de codebase in Ionic niet alleen kan dienen voor het ontwikkelen van mobiele applicaties, net zoals React Native, maar dat dezelfde codebase ook kan gebruikt worden voor het ontwikkelen van de website zelf. Een ontwikkelaar kan dus zijn of haar applicatie uitrollen op drie platformen tegelijk. Dit onderzoek zal zich specifiek focussen op Ionic in samenwerking met React. Dit vanwege het feit dat React Native ook steunt op React en dat er op deze manier een zeer nauwkeurig beeld kan gegeven worden tussen beide frameworks. Indien er voor een andere framework gekozen zou zijn, zoals bijvoorbeeld Angular of Vue, zou het mogelijk zijn dat bepaalde performantieverschillen eerder te wijten zijn aan de verschillen tussen Angular en React, dan tussen React Native en Ionic.

"Ionic React" maakt gebruik van dezelfde React componenten zoals React Native. Er wordt dus opnieuw gesteund op JSX-componenten, met bovendien extra flexibiliteit van webtechnologieën zoals HTML en CSS. Veel Ionic mobiele applicaties starten eigenlijk vaak als een webapplicatie die vervolgens wordt omgezet naar een mobiele applicatie. Vroeger gebeurde deze omzetting via Cordova, maar ondertussen heeft Ionic hun eigen versie ontwikkeld, genaamd Capacitor. (TODO: Nog wat extra algemene info Capacitor)

Via de Capacitor CLI kan de ontwikkelaar via een simpele commando zijn of haar React applicatie laten builden naar een native Android en/of iOS applicatie. Dit gebeurt door de webapplicatie te bundelen en vervolgens in een native container te plaatsen. Vervolgens wanneer de applicatie wordt geopend, wordt de native webview van het platform aangesproken en de 
componenten ingeladen. Het is als het ware een webapplicatie die in een native container draait. De applicatie kan bovendien nog steeds gebruikmaken van native functionaliteiten zoals de camera, GPS, enzoverder (hoe?). (TODO: misschien erbij vermelden hoe de conversie plaatsvindt?)

%Deze kan hierdoor nog steeds gebruikmaken van verschillende native functionaliteiten zoals de camera, GPS, enzoverder. Het grote verschil met het framework React Native is dat bij Ionic de mobiele applicatie in een webview wordt geplaatst. 


%OPMERKING: To use an Android Emulator you must use an API 24+ system image. The System WebView does not automatically update on emulators. Physical devices should work as low as API 21 as long as their System WebView is updated.



verschil afb

(TODO: afbeelding toelichten)
\paragraph{Performantie}

(nog te schrijven)
Hierin zal er onder meer gesproken worden over de performantie van mobiele applicaties omtrent streaming en hoe dit een impact kan hebben op de keuze van het framework. De belangrijkste performance-indicatoren zullen hierbij besproken worden.

%Dit hoofdstuk bevat je literatuurstudie. De inhoud gaat verder op de inleiding, maar zal het onderwerp van de bachelorproef *diepgaand* uitspitten. De bedoeling is dat de lezer na lezing van dit hoofdstuk helemaal op de hoogte is van de huidige stand van zaken (state-of-the-art) in het onderzoeksdomein. Iemand die niet vertrouwd is met het onderwerp, weet nu voldoende om de rest van het verhaal te kunnen volgen, zonder dat die er nog andere informatie moet over opzoeken \autocite{Pollefliet2011}.

%Je verwijst bij elke bewering die je doet, vakterm die je introduceert, enz.\ naar je bronnen. In \LaTeX{} kan dat met het commando \texttt{$\backslash${textcite\{\}}} of \texttt{$\backslash${autocite\{\}}}. Als argument van het commando geef je de ``sleutel'' van een ``record'' in een bibliografische databank in het Bib\LaTeX{}-formaat (een tekstbestand). Als je expliciet naar de auteur verwijst in de zin (narratieve referentie), gebruik je \texttt{$\backslash${}textcite\{\}}. Soms is de auteursnaam niet expliciet een onderdeel van de zin, dan gebruik je \texttt{$\backslash${}autocite\{\}} (referentie tussen haakjes). Dit gebruik je bv.~bij een citaat, of om in het bijschrift van een overgenomen afbeelding, broncode, tabel, enz. te verwijzen naar de bron. In de volgende paragraaf een voorbeeld van elk.

%\textcite{Knuth1998} schreef een van de standaardwerken over sorteer- en zoekalgoritmen. Experten zijn het erover eens dat cloud computing een interessante opportuniteit vormen, zowel voor gebruikers als voor dienstverleners op vlak van informatietechnologie~\autocite{Creeger2009}.

%Let er ook op: het \texttt{cite}-commando voor de punt, dus binnen de zin. Je verwijst meteen naar een bron in de eerste zin die erop gebaseerd is, dus niet pas op het einde van een paragraaf.

\lipsum[7-20]
