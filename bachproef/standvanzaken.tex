\chapter{\IfLanguageName{dutch}{Stand van zaken}{State of the art}}%
\label{ch:stand-van-zaken}

% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.

In dit hoofdstuk wordt de huidige stand van zaken besproken binnen het onderzoeksdomein. Het doel is om een duidelijk beeld te scheppen van de huidige situatie en de bestaande kennis over het onderwerp en zo een goede basis te vormen voor het verdere verloop van het onderzoek. In dit hoofdstok wordt er eerst gesproken over het verschil tussen Native, Cross-Platform en Hybrid Development. Het is namelijk noodzakelijk hier een goed beeld van te vormen om de juiste omkadering te geven van beide frameworks. Vervolgens wordt er dieper ingegaan op de Android infrastructuur. Vanwege de verschillen tussen de infrastructuur en werking van React Native en Ionic, is het belangrijk ook een begrip te hebben van de onderliggende componenten en hun relaties. Daarna zal er een vergelijking gemaakt worden tussen de twee frameworks en zullen er verklaringen of redenen gegeven worden op welke vlakken zij kunnen verschillen en waarom. Tot slot wordt er nog een korte paragraaf gewijd aan de performantie van mobiele applicaties omtrent streaming en hoe dit een impact kan hebben op de keuze van het framework.

\paragraph{Native vs Cross-Platform vs Hybrid}

Voordat er dieper ingegaan wordt op React Native en Ionic, is het belangrijk om ze te situeren binnen Mobile Development. Er kunnen drie grote categorieën onderscheiden worden: Native, Cross-Platform en Hybrid. Native Development is het "native" ontwikkelen van een applicatie voor een specifiek platform. Dit wil zeggen dat een applicatie ontwikkeld wordt in de programmeertaal van het platform, zoals Java of Kotlin voor Android-toestellen en Objective-C of Swift voor iOS-toestellen (bron 11, bron 1). Met andere woorden maken deze applicaties gebruik van de officiële ontwikkelingsomgevingen en architecturen van de platform in kwestie. Dit brengt een aantal voordelen met zich mee. Door het gebruik van de native-architectuur en native-UI-tools, kan men profiteren van alle functionaliteiten die het platform aanbiedt. Dat zorgt dan weer voor een optimale performantie en bijgevolg een betere gebruikservaring. Bovendien vereisen bepaalde applicaties een native ontwikkeling. Denk hierbij aan applicaties die 
 enzoverder (bron). De keuze voor een native-aanpak brengt echter toch nadelen met zich mee. Mobiele applicaties worden echter vaak ontwikkeld met meerdere platformen in gedachten, waardoor dezelfde app als het ware dubbel moet worden geprogrammeerd, met als gevolg hogere kosten en development tijd??(bron). Bovendien vereist dit extra kennis van de medewerkers en ontwikkelaars omdat er voor elk platform een andere programmeertaal gebruikt wordt. Kleinere organisaties of start-ups hebben niet altijd voldoende middelen om zulke projecten te financieren. Vandaar dat Cross-Platform en Hybrid Development een oplossing kunnen bieden.

Het grote voordeel aan Cross-Platform development is dat het gebruik maakt van het principe: "write once, run everywhere" (bron??). Dit wil zeggen dat ontwikkelaars de applicatie slechts één keer moeten schrijven in een programmeertaal naar keuze en vervolgens uitrollen op één of meerdere platformen zonder hierbij platform-specifieke code te moeten herschrijven (bron). In vele gevallen maakt men gebruik van een framework dat gebaseerd is op talen die ondersteund worden op meerdere platformen, zoals bijvoorbeeld JavaScript. Vervolgens maakt het framework gebruik van een cross-compiler die de code vertaalt naar de platformspecifieke code. De applicatie heeft bijgevolg een soort van "native" look-and-feel, onder meer omdat Native-componenten van het toestel hergebruikt worden. Belangrijk hierbij te vermelden is dat het nog altijd geen echte Native-applicatie is vanwege de cross-compiler. Deze tussenstap brengt namelijk een zekere overhead met zich mee, wat kan leiden tot een mindere performantie in vergelijking met een Native-applicatie. Bovendien is het niet altijd mogelijk om alle platformspecifieke functionaliteiten te gebruiken. Wat deze beperkingen zijn, hangt natuurlijk af van framework tot framework. Wat wel vaststaat is dat Cross-Platform Development, in tegenstelling tot Native Development, een pak goedkoper is en sneller verloopt juist vanwege het feit dat er slechts één codebase is.

Tot slot is er nog Hybrid Development. Deze vorm bevindt zich ergens tussen Native en Cross-Platform Development. Uit verschillende bronnen bleek dat de termen Cross-Platform en Hybrid Development vaak door elkaar worden gebruikt, terwijl er toch een aanzienlijk verschil is tussen beiden. Hybrid Development maakt gebruik van webtechnologieën zoals HTML, CSS en JavaScript om een applicatie te ontwikkelen. Er is hier dus opnieuw sprake van herbruikbare code en dus het eenmalig implementeren van de applicatie. Het grote verschil met Cross-Platform Development is dat Hybrid Development de code in een webview of browser-engine van het platform plaatst. Bij Android is dit het WebView component, bij iOS wordt het UIWebView component gebruikt (bron4). Vervolgens wordt de applicatie verpakt in een native container waardoor de applicatie een soort van "native" applicatie wordt. Toch valt hierbij op te merken dat de applicatie niet Native is, en ook geen gebruik maakt van Native-componenten zoals bij Cross-Platform Development. Omdat Hybrid applicaties dus ook geen gebruik maken van Native-componenten, kampen zij vaak met inconsistente User Interface, wat natuurlijk een impact heeft op de gebruikerservaring.

Het verschil tussen Cross-Platform en Hybrid development vormt een kernaspect binnen dit onderzoek. Ionic wordt namelijk bestempeld als een Hybrid framework, terwijl React Native een Cross-Platform framework is. Beiden zijn echter mogelijkheden om eenmalig een programma te coderen en vervolgens uit te rollen op meerdere platformen. Beiden zijn echter ook niet Native, met de bijhorende impact op de performantie. Hoe de infrastructuur van beide frameworks in elkaar zit, zal in een volgende paragraaf besproken worden.


\paragraph{Android infrastructuur}

Een belangrijk aspect van dit onderzoek is de infrastructuur van Android. Android is een besturingssysteem ontwikkeld door Google en is gebaseerd op de Linux-kernel. Het besturingssysteem is open-source en wordt voornamelijk gebruikt op smartphones en tablets. Marktaandeel +++
programmeertaal++++

Het Android besturingssysteem is opgebouwd uit een aantal lagen. De eerste en bovenste laag is de System Apps of systeemapplicaties. Dit zijn de applicaties die standaard geïnstalleerd zijn op elk Android-toestel. Denk hierbij aan de telefoon-applicatie, de berichten-applicatie, de email-applicatie, enzoverder. Deze standaardapplicaties hebben verder geen speciale betekenis naast het feit dat ze standaard met het besturingssysteem worden geïnstalleerd. De standaardbrowser die met het toestel komt, kan nog altijd vervangen worden door een andere browser.

De tweede laag noemt de Java API Framework. Dit is het framework dat ontwikkelaars gebruiken om applicaties te ontwikkelen voor Android. Het bevat een verzameling aan API's geschreven in Java die de features voorstellen van het Android OS. Het bevat een "View System" die de ontwikkelaar de mogelijkheid biedt om via buttons, grids, textboxes, enzoverder een User Interface te creëren. Hierbinnen zit ook een web browser engine die belangrijk is binnenin Hybrid Development (zie ook++++). Content Providers is een ander onderdeel binnenin het Java API Framework. Dit is een soort mechanisme die het mogelijk maakt om data van andere applicaties te delen. Een voorbeeld hiervan is de Contact Provider die een gebruiker toelaat om contactinformatie uit de contacten-app te hergebruiken of zelf delen met de applicatie, of zelf de Calendar Provider om events of afspraken op de agenda-app op te slaan of ook te delen. Tot slot zijn er ook nog de verschillende Managers binnen de Java API Framework. Deze staan in voor de verschillende services die het Android OS aanbiedt. Zo is er de Notification Manager die instaat voor de notificaties en de Location Manager die de locatie van de gebruiker kan bepalen, om enkele voorbeelden te geven.

De volgende laag is de Native C/C++ Libraries. Een groot deel van de belangrijkste componenten van het Android besturingssysteem zijn geschreven in C/C++. Android staat toe om veel van deze libraries via een Java API te gebruiken. Toch kan het mogelijk zijn dat een ontwikkelaar zijn applicatie in C/C++ wil schrijven. Dankzij deze laag kan er op een Native manier in C/C++ geprogrammeerd worden dankzij deze libraries. Om toch deze laag nog wat beter uit te leggen kan dit geïllustreerd worden aan de hand van een voorbeeld. Stel dat een ontwikkelaar bepaalde 2D of 3D objecten wil gaan renderen in zijn applicatie, denk hierbij aan games. De Native C/C++ Libraries bevatten de OpenGL ES library die aan de hand van C/C++ objecten kan renderen. Toch is het ook mogelijk om deze library te gebruiken in de bovenstaande Java API Framework laag met behulp van de Java OpenGL API. Zo is het nog steeds mogelijk om via Java objecten te renderen, maar dan wel met behulp van de OpenGL ES library. Deze laag kan eigenlijk gebruikt worden om op een meer Native manier te programmeren, maar is niet noodzakelijk voor de ontwikkeling van een Android-applicatie, maar het kan mogelijks extra flexibiliteit bieden.

Vervolgens is er de Android Runtime. Dit is de laag waar de applicaties worden uitgevoerd. Hierbij is het belangrijkste component de Android Runtime (ART). Elke applicatie die op het Android OS draait, runt in een eigen proces met een eigen instantie van dit ART component. ART maakt gebruik van Dalvik Executable (.dex) bestanden, een bestandsformaat dat specifiek is ontwikkeld voor Android en geoptimaliseerd is om applicaties te draaien met lage geheugenvereisten. Hierin schuilt als het ware de kracht om soms zelf zware applicaties te draaien op een toestel met relatief beperkte resources. Bovendien biedt ART verschillende runtime functionaliteiten zoals Ahead-of-time (AOT), Just-in-time (JIT) compilatie en garbage collection mogelijkheden. AOT compilatie zorgt ervoor dat de applicatie gecompileerd wordt voordat deze wordt uitgevoerd, wat de performantie ten goede komt. JIT compilatie daarentegen compileert de applicatie tijdens het uitvoeren, wat de opstarttijd van de applicatie ten goede komt. ART is de opvolger van Dalvik, de vorige runtime van Android. Dalvik maakte gebruik van Just-in-time compilatie (bron???), wat de opstarttijd van applicaties vertraagde. ART is geïntroduceerd in Android 5.0 (Lollipop???) en is sindsdien de standaard runtime van Android (bron???).

Vervolgens komen we bij de voorlaatste laag, namelijk de Hardware Abstraction Layer of kortweg HAL. Deze laag biedt meerdere interfaces aan om te kunnen communiceren met de onderliggende hardwarelaag. Zo voorkomt deze laag dat ontwikkelaars rechtstreeks met de hardware moeten communiceren. Zo hebben de camera, de Bluetooth, de audio, enzoverder allemaal een eigen interface. Wanneer een API framework uit de bovenliggende laag een bepaalde hardwarefunctie wil gebruiken, zal de HAL de desbetreffende library module inladen. Deze module zal dan de hardwarefunctie aanroepen en de resultaten terugsturen naar de API framework.

Tot slot is er nog de laatste laag: de Linux Kernel. Dit wordt ook wel gezien als de kern van het Android platform. Een belangrijk proces is dat de ART component deze kernel gebruikt om het geheugen en de processen te beheren. Zaken zoals threading en low-level memory management worden hier geregeld. Het grote voordeel van de Linux Kernel is dat het een hele grote community heeft die constant werkt aan het verbeteren van zaken zoals security (https://source.android.com/docs/security/overview/kernel-security)+++. Vanuit deze laag wordt er uiteindelijk gecommuniceerd met de hardware van het toestel om de applicatie te kunnen draaien.

\paragraph{React Native}

Dit onderzoek focust zich specifiek op React Native en Ionic. React Native is een open-source framework ontwikkeld door Facebook. Het werd gelanceerd in 2015 en was oorspronkelijk bedoeld voor het ontwikkelen van mobiele applicaties voor iOS-toestellen (bron1). In september van dat jaar, enkele maanden na de initiële lancering, was het ook mogelijk om via dezelfde codebase de applicatie te lanceren op Android (bron1). React Native maakt gebruik van het React framework, een ander open source framework die aan de hand van JavaScript de mogelijkheid biedt om complexe user interfaces te maken (https://reactnative.dev/docs/intro-react#your-first-component). Een applicatie gebouwd in React Native en React maakt gebruik van JSX-componenten, een combinatie tussen XML binnenin JavaScript code, wat bovendien extra flexibiliteit geeft om ook variabelen te declareren binnen dezelfde componenten (bron2?).

Bij zowel Android als iOS-development bestaat de UI uit "views" (https://reactnative.dev/docs/intro-react-native-components). Deze vormen de bouwstenen van de applicatie en kunnen opgebouwd worden uit verschillende componenten. React Native biedt een groot aantal standaardcomponenten zoals buttons, inputvelden, sliders, enzoverder. Het principe achter React Native is dat je deze views binnenin Android en iOS kunt gebruiken aan de hand van React componenten. Het "<TextInput>" component binnenin React Native bijvoorbeeld, wordt omgezet naar een "<EditText>" view in Android en een "<UITextField>" view in iOS.


++ Nu wat dieper ingaan in rendering blablabla
De React Native applicatie voor de Proof-of-Concept zal gebruikmaken van het nieuwe Fabric-rendering principe. Hiervoor maakte React Native gebruik van "The Bridge", waarbij de JavaScript code binnenin React werd omgezet naar Native-componenten (bron???). Dit principe is helemaal vernieuwd met behulp van Fabric. Om de complexiteit zo laag mogelijk te houden, zal dit uitgelegd worden aan de hand van een voorbeeld. In onderstaand voorbeeld hebben we een React-component "Component" gedefiniëerd. Deze component bevat een <View> component met daarin een <Text> component. De code ziet er als volgt uit:

CODE: function Component() {
  return (
    <View>
      <Text>Hello, World</Text>
    </View>
  );
}

In React onderscheiden we twee type components: React Composite Components en React Host Components. React Composite Components zijn de componenten die door de ontwikkelaar zelf gedefinieerd worden, zoals de "Component" component in bovenstaande code. React Host Components zijn de standaardcomponenten die React Native aanbiedt, zoals de <View> en <Text> componenten (https://reactnative.dev/architecture/glossary#react-composite-components). Eens de code moet worden gerendered, zal React deze gedefinieerde componenten eerst omzetten in een React Element Tree. Hierbij worden alle React Host Components, maar niet de zelf gedeclareerde React Composite Components, omgezet naar een boomstructuur van React Elementen. Een React Element is een JavaScript object die alle informatie bevat over het component en wat er precies op het scherm moet worden weergegeven (https://reactnative.dev/architecture/glossary#react-element-tree-and-react-element). Tegelijkertijd gaat de Fabric renderer een Shadow Tree aanmaken. Voor elk React Element wordt een React Shadow Node aangemaakt en wordt deze in een gelijkaardige boomstructuur gestoken. Het verschil tussen een React Element en een React Shadow Node is dat de React Element in JavaScript is gedefinieerd en de React Shadow Node in C++ (https://reactnative.dev/architecture/glossary#react-shadow-node). Zo bestaat er in het bovenstaande voorbeeld een React Element <View> en een React Shadow Node <ViewShadowNode>. Nadat de Shadow Tree is aangemaakt, wordt er een commit getriggered.

(insert foto)

De volgende fase is de Commit fase. Deze bestaat uit twee grote stappen: de Layout Calculation en Tree Promotion. Bij Layout Calculation wordt alle informatie omtrent de layout, die oorspronkelijk afkomstig is van de React Element Tree, berekend. Zo wordt voor elk component bepaald hoeveel ruimte ze gaat innemen op het scherm. Bij Tree Promotion wordt de nieuwe Shadow Tree als het ware "gepromoveerd" en klaargezet om gemounted te worden. In eenvoudigere termen betekent dit dat de nieuwe Shadow Tree klaarstaat om op het scherm te worden weergegeven. Zowel de Layout Calculation als de Tree Promotion verlopen asynchroon met elkaar en worden voor het grootste deel in C++ berekend.

De laatste fase, de Mount fase, bestaat tot slot in het renderen van het scherm. Hierbij wordt voor elke React Shadow Node uit de Shadow Tree samen met de berekende layout informatie een Host View aangemaakt. Een Host View is een View die een instantie is van een Android View of een iOS UIView. De React Shadow Nodes worden dus omgezet naar View componenten afhankelijk van het Host platform+++. Hierbij wordt er dus gebruik gemaakt van de Native-componenten van het desbetreffende besturingssysteem, vandaar de term "Native" in React Native.
+++

Fout statement full native

Cross-platform

https://reactnative.dev/architecture/render-pipeline
https://reactnative.dev/architecture/glossary
https://reactnative.dev/docs/intro-react

\paragraph{Ionic}

https://ionic.io/resources/articles/building-cross-platform-apps-with-capacitor
https://ionicframework.com/docs#license
https://capacitorjs.com/docs/android

Ionic is net zoals React Native een open source framework. {bron8} laat toe om via een webframework naar keuze zoals Angular, React of Vue een applicatie te ontwikkelen die vervolgens kan uitgerold worden op meerdere platformen. Het grote voordeel aan Ionic is dat het gebruik maakt van webtechnologieën zoals HTML, CSS en JavaScript. Dit heeft als gevolg dat de codebase in Ionic niet alleen kan dienen voor het ontwikkelen van mobiele applicaties net zoals React Native, maar dat dezelfde codebase ook kan gebruikt worden voor het ontwikkelen van de website zelf. Een ontwikkelaar kan zijn of haar applicatie uitrollen op drie platformen tegelijk. Dit onderzoek zal zich specifiek focussen op Ionic in samenwerking met React. Dit vanwege het feit dat React Native gebruik maakt van React en dat er op deze manier een zeer nauwkeurig beeld kan gegeven worden tussen beide frameworks. Indien er voor een andere framework gekozen zou zijn zoals bijvoorbeeld Angular of Vue, zou het mogelijk zijn dat bepaalde performantieverschillen eerder te wijten zijn aan de verschillen tussen Angular en React, dan tussen React Native en Ionic.

"Ionic React" maakt gebruik van dezelfde React componenten zoals React Native. Er wordt opnieuw gebruik gemaakt van JSX-componenten, met de extra flexibiliteit door het gebruik van HTML en CSS. Veel Ionic mobiele applicaties starten dus eigenlijk als een webapplicatie die vervolgens wordt omgezet naar een mobiele applicatie. Vroeger gebeurde deze omzetting via Cordova, maar ondertussen heeft Ionic hun eigen versie ontwikkeld, genaamd Capacitor. Het is een open source project en biedt de mogelijkheid om ++++

Via de Capacitor CLI kan de ontwikkelaar via een simpele commando zijn of haar React applicatie laten builden naar een native Android en/of iOS applicatie. Dit gebeurt door de webapplicatie te bundelen en vervolgens in een native container te plaatsen. Deze applicatie kan hierdoor nog steeds gebruikmaken van verschillende native functionaliteiten zoals de camera, GPS, enzoverder. Het grote verschil met het framework React Native is dat bij Ionic de mobiele applicatie in een webview wordt geplaatst. 


OPMERKING: To use an Android Emulator you must use an API 24+ system image. The System WebView does not automatically update on emulators. Physical devices should work as low as API 21 as long as their System WebView is updated.



verschil afb
\paragraph{Performantie}

Dit hoofdstuk bevat je literatuurstudie. De inhoud gaat verder op de inleiding, maar zal het onderwerp van de bachelorproef *diepgaand* uitspitten. De bedoeling is dat de lezer na lezing van dit hoofdstuk helemaal op de hoogte is van de huidige stand van zaken (state-of-the-art) in het onderzoeksdomein. Iemand die niet vertrouwd is met het onderwerp, weet nu voldoende om de rest van het verhaal te kunnen volgen, zonder dat die er nog andere informatie moet over opzoeken \autocite{Pollefliet2011}.

Je verwijst bij elke bewering die je doet, vakterm die je introduceert, enz.\ naar je bronnen. In \LaTeX{} kan dat met het commando \texttt{$\backslash${textcite\{\}}} of \texttt{$\backslash${autocite\{\}}}. Als argument van het commando geef je de ``sleutel'' van een ``record'' in een bibliografische databank in het Bib\LaTeX{}-formaat (een tekstbestand). Als je expliciet naar de auteur verwijst in de zin (narratieve referentie), gebruik je \texttt{$\backslash${}textcite\{\}}. Soms is de auteursnaam niet expliciet een onderdeel van de zin, dan gebruik je \texttt{$\backslash${}autocite\{\}} (referentie tussen haakjes). Dit gebruik je bv.~bij een citaat, of om in het bijschrift van een overgenomen afbeelding, broncode, tabel, enz. te verwijzen naar de bron. In de volgende paragraaf een voorbeeld van elk.

\textcite{Knuth1998} schreef een van de standaardwerken over sorteer- en zoekalgoritmen. Experten zijn het erover eens dat cloud computing een interessante opportuniteit vormen, zowel voor gebruikers als voor dienstverleners op vlak van informatietechnologie~\autocite{Creeger2009}.

Let er ook op: het \texttt{cite}-commando voor de punt, dus binnen de zin. Je verwijst meteen naar een bron in de eerste zin die erop gebaseerd is, dus niet pas op het einde van een paragraaf.

\lipsum[7-20]
