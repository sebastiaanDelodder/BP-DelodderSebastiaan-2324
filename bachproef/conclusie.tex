%%=============================================================================
%% Conclusie
%%=============================================================================

\chapter{Conclusie}%
\label{ch:conclusie}

% TODO: Trek een duidelijke conclusie, in de vorm van een antwoord op de
% onderzoeksvra(a)g(en). Wat was jouw bijdrage aan het onderzoeksdomein en
% hoe biedt dit meerwaarde aan het vakgebied/doelgroep? 
% Reflecteer kritisch over het resultaat. In Engelse teksten wordt deze sectie
% ``Discussion'' genoemd. Had je deze uitkomst verwacht? Zijn er zaken die nog
% niet duidelijk zijn?
% Heeft het onderzoek geleid tot nieuwe vragen die uitnodigen tot verder 
%onderzoek?

Met de Proof-of-Concept kon er een duidelijk en uitgebreid beeld geschetst worden van de verschillen tussen React Native en Ionic omtrent streaming en de impact op de performantie. Het is nu belangrijk de bevindingen hier te bespreken en een verklaring te bieden voor de verschijnselen die zich voordeden. Tot slot zal er ook nog een aanleg gegeven worden voor toekomstig onderzoek binnen dit domein en nog een kleine reflectie gegeven worden.

\section{Verklaringen}
\label{sec:verklaringen}

Een eerste aspect dat werd onderzocht, waren de laadtijden van de applicaties. Zowel de cold als de warm startup-tijden werden hierbij gemeten. Het grootste verschil was op te merken bij de initiële opstart, waarbij Ionic een zeer grote voorsprong had op React Native met een verschil van minimum 3 seconden. De verklaring hiervoor is dat Ionic namelijk enkel en alleen, in het geval van de streaming-applicatie, het WebView-component moest raadplegen. React Native daarentegen maakt gebruik van verschillende andere componenten van het Android OS en moet bijgevolg meer tijd spenderen aan het inladen en renderen van deze componenten. De warm startup-tijden waren dan weer vrij gelijkaardig. Hoewel React Native een kleine voorsprong had, ging dit slechts over enkele milliseconden en is dit verschil vrijwel verwaarloosbaar. Dit valt dan weer te verklaren doordat de applicatie reeds opgestart is en de componenten reeds in het geheugen ingeladen zijn.

Een volgend onderdeel uit de Proof-of-Concept, was de interactie met de app. Hierbij bleek het verschil opnieuw te gaan over enkele honderden milliseconden. Ionic kwam net iets beter uit de resultaten dan React Native. Dit valt opnieuw te verklaren door het feit dat React Native met meer native componenten moet werken, waardoor er een kleine vertraging optreedt. Ondanks dat dit over enkele milliseconden gaat, kan dit toch een effect hebben op de gebruikerservaring. Indien een gebruiker snel zou willen wisselen tussen de video's, kan dit kleine verschil toch na een tijdje beginnen oplopen, waardoor er niet langer over milliseconden gesproken moet worden, maar eerder over seconden. Beide applicaties scoorden echter even goed op het effectieve streamen van de video's. De haperingen die optraden of het geluid dat niet altijd even synchroon met het beeld was, waren eerder te wijten aan de emulator zelf, dan aan de applicaties. Dit vanwege het feit dat deze vertragingen ook aanwezig waren bij het scrollen tussen de applicaties van het toestel en bij het navigeren op het web.

Het CPU-gebruik kan verdeeld worden in twee groepen op basis van de resultaten: het opstarten van de applicatie en het streamen van een video. Bij het opstarten bleek React Native de betere oplossing te zijn. Ionic moet namelijk bij de initiële opstart de code eerst nog compilen in de WebView, waardoor er een iets hogere piek in het CPU-gebruik optreedt. React Native daarentegen heeft deze stap in mindere mate nodig omdat deze rechtstreeks communiceert met de View-elementen van het OS zelf. Het streamen zelf verliep dan weer iets beter bij Ionic. Dit valt te verklaren omdat de WebView bij Ionic geoptimaliseerd is om videobestanden af te spelen en om te gaan met andere multimedia. React Native moet opnieuw met de verschillende OS-componenten communiceren, en vanwege de Fabric-architectuur die React Native hanteert, waarbij er zowel met JavaScript als met C++ gecommuniceerd wordt om de componenten te renderen, kan dit een verklaring zijn voor het hogere CPU-gebruik. Daarnaast had de hogere videoresolutie ook een invloed op het CPU-gebruik. Hoe hoger de resolutie, hoe meer rekenkracht er nodig is om de video af te spelen.

Tot slot werd er ook nog gekeken naar het geheugengebruik van beide applicaties. Eens de applicatie was opgestart leek het verschil aanvankelijk nog vrij miniem, maar toen de video begon te streamen, werd het verschil al snel duidelijk. React Native had een veel hoger geheugengebruik dan Ionic. Ook hier kan dezelfde verklaring worden gegeven als bij het CPU-gebruik. React Native moet met verschillende componenten van het OS communiceren die ingeladen zijn in het geheugen. Bovendien zorgt het gebruik van de Fabric-architectuur ervoor dat er meer complexe data onthouden moet worden om de componenten te renderen, hoe de video te decoden en natuurlijk af te spelen.

Er kan dus besloten worden dat over het algemeen Ionic beter scoorde dan React Native. Dit kan misschien zelf gezien worden als een eerder onverwacht resultaat voor sommigen, omdat uit verschillende bronnen vaak wordt beweerd dat Cross-Platform frameworks een performantie-voordeel hebben ten opzichte van Hybrid frameworks door het gebruik van native componenten. Deze mindset lijkt nog sterk ingeburgerd te zijn ondanks dat deze beweringen vaak op basis waren van onderzoeken die al lang achterhaald zijn. Het is dus belangrijk om steeds de nieuwste technologieën te onderzoeken en te vergelijken met elkaar om zo een correct beeld te krijgen van de huidige stand van zaken.

\section{Toekomstig onderzoek}
\label{sec:toekomstig-onderzoek}

De Proof-of-Concept heeft een duidelijk beeld geschetst van de verschillen tussen React Native en Ionic omtrent streaming. Toch zijn er nog enkele zaken die verder onderzocht kunnen worden naar de toekomst toe. Zo werd er voor dit onderzoek specifiek gekeken naar het Ionic-framework omdat deze toelaat om naast het gebruik van webtechnologieën ook gebruik te maken van native componenten van het OS zelf, zoals bijvoorbeeld de GPS of de camera. Hier werd er echter niet dieper op ingegaan. Het zou bijvoorbeeld interessant kunnen zijn om te onderzoeken hoe Ionic precies omgaat met deze native componenten en welke impact dit heeft op de performantie van de applicatie. Dit kan dan opnieuw vergeleken worden met React Native of eventueel een ander Cross-Platform framework om zo ook het native-aspect te vergelijken tussen Hybrid en Cross-Platform frameworks.


\section{Korte reflectie}
\label{sec:korte-reflectie}

Het principe dat er altijd native ontwikkeld moet worden voor de beste performantie, lijkt nog iets te zijn dat sterk ingeburgerd is in de ontwikkelingswereld. Desondanks kampen IT-bedrijven of programmeurs soms met een beperkt budget om een applicatie meermaals te implementeren op verschillende platformen. Dit onderzoek was dan ook vooral voor hen bedoeld om een duidelijk beeld te schetsen van de verschillen tussen Cross-Platform en Hybrid frameworks. Hoewel de keuze van het framework afhankelijk is van de noden van de applicatie, kan er toch besloten worden dat Ionic op vlak van prestaties beter scoort dan React Native als het gaat over streaming. Dit kan dan ook een belangrijke factor zijn bij het maken van een keuze voor een framework. Daarnaast valt wel op te merken dat Ionic nog vooral steunt op hun eigen community om native functionaliteiten te implementeren, terwijl React Native hier al een stuk verder in staat. De keuze van het framework zal dus vooral afhangen van de noden van de applicatie en wat het te bereiken doel is.